-----
config.ini für Mapping von DBus-Gegenstellen:
-----
Remaining issues:
- Validity checks for read values should be incorporated in DBusAddressTranslator::readValue
  * Don't forget to ignore any non-"local" domains
- Error handling for DBusUtils.h::getBinaryFileName
  * When one of the defined error codes is thrown
- Incorporate checks on binary-file-name-retrieval in unit test.
- Incorporate test on cooperation of "Factory::getAvailableServices" and the DBusAddressTranslator

-----
MainLoop-Integration:
-----
Already working:
- Prototypical implementation of MainLoopIntegration
  * Vorbild vorerst glib
  * Andere bereits recherchiert
- MainLoop
  * Creation of MainLoopContext within Runtime
  * Creation of Factories with registered MainLoop
  * Start automatic dispatch depending on presence of a MainLoopContext
  * Support of libdbus-watches
  * Sending and receiving messages by using mainloop iteration

TODO:
- Workflow, um an den Mainloop-Kontext zu kommen, festlegen
- Push auf master: Bei "Refs" statt "Heads" ein "Fork", damits auf Gerrit kommt
- Dispatch für synchrone Aufrufe sind immer noch zwei Threads!
- connection: dispatch-thread dort rein, var auf false, sync per join
- Tests Stückweise wieder integrieren!
- Brauchen wir wirklich die CommonAPI::Connection? Ich hoffe ja, dass nicht.
- Implementierung der memory-free-functions? Sinnvoll, notwendig?
- Verbindungs-Wiederaufbau nach -abriss?
Rückmeldung Martin Haefner:
Bezgl. des Threadings bin ich auch noch gespalten. Hier gibt es niemanden mit dem ich ganz unvoreingenommen drüber diskutieren könnte. Ich hab mir das Modell von ICE angeschaut.
Die benutzen ein Leader/Follower Pattern um ihre Requests auf Serverseite auf Threads zu verteilen. Auf Clientseite kann man sich auch einiges denken.
Momentan bin ich noch etwas unzufrieden bezgl. des futures das bei den asynchronen Requests verwendet wird.
Ich bin irgendwie immernoch der Meinung, dass die ganze API auch in einem einzelnen Thread funktionieren müsste und dann darf der Thread eben nicht in der Waitcondition des Futures blockieren
sondern muss im Hintergrund etwas tun. Das hab ich in einer eigenen IPC-Library umgesetzt.
Dort gibt es eine generische waitForResponse(Request) Funktion die auf die Antwort wartet, aber eben nirgends blockiert sondern in den Dispatcher reinläuft.
Ich hätte daher ein Objekt bevorzugt das zwar das Interface des Futures hat aber eben kein std::future ist und somit im Hintergrund impl. abhängig etwas anderes machen kann (concept).



-----
"Major Features":
-----
* Improved UI for generator, e.g. visible and understandable error messages
* CLI für Generator
* Vollständige Elimination Middleware-spezifische Generierung
* Dynamisches Laden v. ein oder mehereren Middelware-Libraries (Konfiguration und aliases via config)


-----
Remains to be sorted/checked/done:
-----
Generierte Map-Datentypen:
- D-Bus eraubt KEINE non-basic-types als key-Werte (siehe spec)!
  --> Verwendung von solchen sollte in Franca verboten oder in CommonAPI erlaubt oder
      als Fehler behandelt werden!

Vererbung von Variants
* Per generierung vollspezialisierter equality- und assignment-operatoren
* Tests dafür

* Fehler im InStream und OutStream: Spezialisierungen für Vektor und allgemeiner "ByteBuffer"-Fall
  (welcher std::vector<uint8_t> ist) behandeln das selbe Thema doppelt!

Serialisierung: Verwenden des Endianness-Flags von D-Bus! Prüfen und beachten von dieser!

Factory: Template-Vorlagen für Attributs-Extensions vlt auslagern in eigenes file?

Bestehende Tests durchgehen und in aktuelle Version überführen!

* Move Version checking to the ServiceRegistry:
    Currently, ensuring the interface-version based compatibility of the local proxy and
    a given remote service would be done asynchronously within the proxy right after its creation.
    The check should be moved to the service registry, so that a proxy only needs to ask
    for the locally cached version information of the remote service.
    According to the current CommonAPI Spec, it is required that a proxy remains "unavailable" when
    it's counterpart has an incompatible interface version.
    Feasibility of and alternatives to this approach remain to be determined.

* Performance:
    Check especially message dispatching! Is it possible to do the dispatching without copying
    the interface name and object path strings?
    Check (de)serialization, improve where possible.

* Dedicated Test of multiple connect/disconnect cycles

* DBus Generator: implizite Array-Deklaration via "[]" (z.B. UInt32[] in Methoden-Aufruf) unterstützen!

- Fall für Structs (und generell):
  * Methode wird aufgerufen, die eine Basis-Struct akzeptieren
  * Struct ist tatsächlich eine vererbte Struct
  * Gesendet wird damit die vererbte Struct, da wir alles über virtual implizit lösen! Problem mit Signatur!

Future development (2.1):

* Request Name for DBusStubAdapter:
    The D-Bus specification states that a single D-Bus connection might own multiple names.
    We have to make sure that when a register request comes from the CommonAPI StubAdapter
    Factory that we make sure that the name is already owned by our DBusConnection.
    Probably we'll have to keep a list of all owned names and request a new one on registration
    if required.

* Doxygen in CommonAPI source code.

- Handling of D-Bus properties!! Sollte auf Franca attributes gemapped sein (Grund: Interoperabilität)

* getValue on attributes is inconsisten with other methods, CallStatus should be in signature not return


-----
"Schöner Wohnen":
-----
Angleichung interface InputStream und OutputStream (mal inline, mal nicht, mal als template, mal spezifisch überladen,...)
