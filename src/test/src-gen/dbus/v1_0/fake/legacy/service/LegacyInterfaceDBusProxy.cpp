/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.2.v201507021046.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v1_0/fake/legacy/service/LegacyInterfaceDBusProxy.hpp>

namespace v1_0 {
namespace fake {
namespace legacy {
namespace service {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createLegacyInterfaceDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<LegacyInterfaceDBusProxy>(_address, _connection);
}

INITIALIZER(registerLegacyInterfaceDBusProxy) {
	CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		LegacyInterface::getInterface(),
		&createLegacyInterfaceDBusProxy);
}

LegacyInterfaceDBusProxy::LegacyInterfaceDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
{
}



        void LegacyInterfaceDBusProxy::TestMethod(const int32_t &_input, CommonAPI::CallStatus &_internalCallStatus, int32_t &_val1, int32_t &_val2, const CommonAPI::CallInfo *_info) {
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_input(_input, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_val1(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_val2(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
            CommonAPI::DBus::DBusProxyHelper<
                CommonAPI::DBus::DBusSerializableArguments<
                CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >
                >,
                CommonAPI::DBus::DBusSerializableArguments<
                    CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>,
                    CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
                >
            >::callMethodWithReply(
            *this,
            "TestMethod",
            "i",
            (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
            deploy_input,
            _internalCallStatus,
            deploy_val1, deploy_val2);
            _val1 = deploy_val1.getValue();
            _val2 = deploy_val2.getValue();
        }
        std::future<CommonAPI::CallStatus> LegacyInterfaceDBusProxy::TestMethodAsync(const int32_t &_input, TestMethodAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_input(_input, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_val1(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_val2(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
            return CommonAPI::DBus::DBusProxyHelper<
                CommonAPI::DBus::DBusSerializableArguments<
                CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment >
                >,
                CommonAPI::DBus::DBusSerializableArguments<
                    CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>,
                    CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
                >
            >::callMethodAsync(
            *this,
            "TestMethod",
            "i",
            (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
            deploy_input,
            [_callback] (CommonAPI::CallStatus _status, CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> _val1, CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> _val2) {
            	_callback(_status, _val1.getValue(), _val2.getValue());
            },
            std::make_tuple(deploy_val1, deploy_val2));
        }
        void LegacyInterfaceDBusProxy::OtherTestMethod(CommonAPI::CallStatus &_internalCallStatus, std::string &_greeting, int32_t &_identifier, const CommonAPI::CallInfo *_info) {
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_greeting(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_identifier(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
            CommonAPI::DBus::DBusProxyHelper<
                CommonAPI::DBus::DBusSerializableArguments<
                >,
                CommonAPI::DBus::DBusSerializableArguments<
                    CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
                    CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
                >
            >::callMethodWithReply(
            *this,
            "OtherTestMethod",
            "",
            (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
            _internalCallStatus,
            deploy_greeting, deploy_identifier);
            _greeting = deploy_greeting.getValue();
            _identifier = deploy_identifier.getValue();
        }
        std::future<CommonAPI::CallStatus> LegacyInterfaceDBusProxy::OtherTestMethodAsync(OtherTestMethodAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_greeting(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
            CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> deploy_identifier(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
            return CommonAPI::DBus::DBusProxyHelper<
                CommonAPI::DBus::DBusSerializableArguments<
                >,
                CommonAPI::DBus::DBusSerializableArguments<
                    CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
                    CommonAPI::Deployable<int32_t,CommonAPI::EmptyDeployment>
                >
            >::callMethodAsync(
            *this,
            "OtherTestMethod",
            "",
            (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
            [_callback] (CommonAPI::CallStatus _status, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _greeting, CommonAPI::Deployable<int32_t, CommonAPI::EmptyDeployment> _identifier) {
            	_callback(_status, _greeting.getValue(), _identifier.getValue());
            },
            std::make_tuple(deploy_greeting, deploy_identifier));
        }
        void LegacyInterfaceDBusProxy::finish(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
            CommonAPI::DBus::DBusProxyHelper<
                CommonAPI::DBus::DBusSerializableArguments<
                >,
                CommonAPI::DBus::DBusSerializableArguments<
                >
            >::callMethodWithReply(
            *this,
            "finish",
            "",
            (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
            _internalCallStatus);
        }
        std::future<CommonAPI::CallStatus> LegacyInterfaceDBusProxy::finishAsync(FinishAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
            return CommonAPI::DBus::DBusProxyHelper<
                CommonAPI::DBus::DBusSerializableArguments<
                >,
                CommonAPI::DBus::DBusSerializableArguments<
                >
            >::callMethodAsync(
            *this,
            "finish",
            "",
            (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
            [_callback] (CommonAPI::CallStatus _status) {
            	_callback(_status);
            },
            std::make_tuple());
        }


        void LegacyInterfaceDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
            ownVersionMajor = 1;
            ownVersionMinor = 0;
        }

        } // namespace service
        } // namespace legacy
        } // namespace fake
        } // namespace v1_0
